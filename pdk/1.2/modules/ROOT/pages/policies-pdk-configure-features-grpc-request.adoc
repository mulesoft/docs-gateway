= Performing a gRPC Call
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

NOTE: To view an example policy project that makes gRPC calls, see https://github.com/mulesoft/pdk-custom-policy-examples/blob/main/simple-oauth-2-grpc-validation/README.md[Simple OAuth 2.0 gRPC Validation Policy Example^].

== gRPC one-shot calls
To interact with external services, the policy must use gRPC calls. You can only make gRPC calls from the request filter or the response filter.
Only one-shot gRPC calls are supported, gRPC streaming calls are not currently possible.

To perform a gRPC call, either inject the `GrpcClient` into the `#[entrypoint]` function or the wrapper functions.

* Injecting the client parameter into the `#[entrypoint]` function enables you to make calls in both the request and response filters:
+
[source,Rust]
----
#[entrypoint]
async fn configure(
    launcher: Launcher,
    Configuration(bytes): Configuration,
    client: grpc::GrpcClient,
) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();

    // Both request and the response handlers will use the client   
    let filter = on_request(|request_state| request_filter(request_state, &config, &client))
        .on_response(|response_state, request_data| {
            response_filter(response_state, request_data, &config, &client)
        });

    launcher.launch(filter).await?;
    Ok(())
}
----

NOTE: All the gRPC client related stuff is placed inside `pdk::hl::grpc` module. If you are following the suggested practice of importing `pdk::hl::*` prelude module, you must refer to gRPC client as `grpc::GrpcClient`.


* Injecting the client parameters into one of the `on_request` or `on_response` wrapper functions enables you to only make calls in that function:
+
[source,Rust]
----
// Handler with the logic for incoming requests
async fn request_filter(state: RequestState, conf: &Config, client: grpc::GrpcClient) {
 ...
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();

    // For incoming request events, using the on_request wrapper, inject the client and pass it to the request_filter handler
    launcher
        .launch(on_request(|request, client| {
            request_filter(request, &config, client)
        }))
        .await?;
    Ok(())
}
----

* Define your service as a parameter in your schema definition to make gRPC requests. To learn more about defining parameters, see xref:policies-pdk-create-schema-definition.adoc[]
The following code snippet provides an example schema definition for an external service:
+
[source,yaml]
----
properties:
      externalService:
          type: string
          format: service
----

* In the policy's Rust source code, you can access the defined external service in the `Config` struct.
Suppose there is a `HelloService` gRPC service with a `SayHello` method, you can invoke it by sending a gRPC message with `grpc::GrpcClient`:

[source,rust]
----

async fn say_hello(config: &Config, client: &GrpcClient, message: &[u8]) -> Result<Vec<u8>, grpc::GrpcClientError> {
    let response = client
        .request(&config.external_service)
        .service("HelloService")
        .method("SayHello")
        .send(message_bytes)
        .await?
        .into_inner()

    Ok(response)
}
----

NOTE: We are sending a message of raw bytes. That message must be explicitly serialized in a selected serialization format such as JSON.

== Protocol Buffers messages
The widely suggested format for interacting with gRPC services is Protocol Buffers. `grpc::GrpcClient` comes with builtin support for it.

* Add the crate `protobuf` as dependency to your `Cargo.toml` file:
+
[source,toml]
----
[dependencies]
pdk = { version = "1.1.0", registry = "anypoint" }
protobuf = "3.5.0"
----

* Check the `protobuf` crate https://crates.io/crates/protobuf[ documentation] for code generation support.
Now suppose that `HelloService` gRPC service has two related messages, `HelloRequest` and `HelloResponse`. You can write
a `grpc::GrpcClient` wrapper for encapsulating calls to `HelloService`.

[source,rust]
----
pub struct HelloClient {
   client: grpc::GrpcClient,
   service: Service,
}

impl HelloClient {
   pub fn new(client: grpc::GrpcClient, service: Service) -> Self {
      Self {
        client,
        service,
      }
   }

   pub fn say_hello(&self, request: &HelloRequest) -> Result<HelloResponse, GrpcClientError> {
      let response = client
        .request(&self.service)
        .service("HelloService")
        .method("SayHello")
        .protobuf() // enable Protocol Buffers support.
        .send(request)
        .await?
        into_inner();

     Ok(response)
   }
----

== See Also

* `protobuf` crate https://crates.io/crates/protobuf[ documentation].
* xref:policies-pdk-configure-features.adoc[]
