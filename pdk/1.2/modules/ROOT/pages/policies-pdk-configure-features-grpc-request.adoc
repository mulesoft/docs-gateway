= Performing a gRPC Call
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

NOTE: To view an example policy project that makes gRPC calls, see https://github.com/mulesoft/pdk-custom-policy-examples/blob/main/simple-oauth-2-grpc-validation/README.md[Simple OAuth 2.0 gRPC Validation Policy Example^].

== gRPC one-shot calls
To interact with external services, the policy must use gRPC calls. You can only make gRPC calls from the request filter or the response filter.
Only one-shot gRPC calls are supported, gRPC streaming calls are not currently possible.

To perform a gRPC call, either inject the `GrpcClient` into the `#[entrypoint]` function or the wrapper functions.

* Injecting the client parameter into the `#[entrypoint]` function enables you to make calls in both the request and response filters:
+
[source,Rust]
----
#[entrypoint]
async fn configure(
    launcher: Launcher,
    Configuration(bytes): Configuration,
    client: grpc::GrpcClient,
) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();

    // Both request and the response handlers will use the client   
    let filter = on_request(|request_state| request_filter(request_state, &config, &client))
        .on_response(|response_state, request_data| {
            response_filter(response_state, request_data, &config, &client)
        });

    launcher.launch(filter).await?;
    Ok(())
}
----

NOTE: All the gRPC client related stuff is placed inside `pdk::hl::grpc` module. If you are following the suggested practice of importing `pdk::hl::*` prelude module, you must refer to gRPC client as `grpc::GrpcClient`.


* Injecting the client parameters into one of the `on_request` or `on_response` wrapper functions enables you to only make calls in that function:
+
[source,Rust]
----
// Handler with the logic for incoming requests
async fn request_filter(state: RequestState, conf: &Config, client: grpc::GrpcClient) {
 ...
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();

    // For incoming request events, using the on_request wrapper, inject the client and pass it to the request_filter handler
    launcher
        .launch(on_request(|request, client| {
            request_filter(request, &config, client)
        }))
        .await?;
    Ok(())
}
----

* Define your service as a parameter in your schema definition to make gRPC requests. To learn more about defining parameters, see xref:policies-pdk-create-schema-definition.adoc[]
The following code snippet provides an example schema definition for an external service:
+
[source,yaml]
----
properties:
      externalService:
          type: string
          format: service
----

* In the policy's Rust source code, you can access the defined external service in the `Config` struct.
Suppose there is a `HelloService` gRPC service with a `SayHello` method, you can invoke it by sending a gRPC message with `grpc::GrpcClient`:

[source,rust]
----

async fn say_hello(config: &Config, client: &GrpcClient, message: &[u8]) -> Result<Vec<u8>, grpc::GrpcClientError> {
    let response = client
        .request(&config.external_service)
        .service("HelloService")
        .method("SayHello")
        .send(message_bytes)
        .await?
        .into_inner()

    Ok(response)
}
----

NOTE: We are sending a message of raw bytes. That message must be explicitly serialized in a selected serialization format such as JSON.

== Protocol Buffers messages
The widely suggested format for interacting with gRPC services is Protocol Buffers. `grpc::GrpcClient` comes with builtin support for it.
PDK depends on the https://crates.io/crates/protobuf[protobuf crate] for encoding Protocol Buffers messages.

* Add the `protobuf` crate to the `dependencies` section of your `Cargo.toml` file:
+
[source,toml]
----
[dependencies]
pdk = { version = "1.1.0", registry = "anypoint" }
protobuf = "3.5.0"
----
* To place `.proto` definition files, create a `proto` directory and place an empty `hello.proto` file inside it:
+
----
└─ proto/  # Contains the Protocol Buffers definition files.
   └── hello.proto # Contains the Protocol Buffers definitions for the `hello` package.
----

* Open the `hello.proto` file and write these definitions on it:
+
[source,proto]
----
syntax = "proto2";

package hello;

service HelloService {
  rpc SayHello(HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  required string greeting = 1;
}

message HelloResponse {
  required string reply = 1;
}
----

* For generating the code to support the Protocol Buffers messages in Rust, add `profobuf-codegen` crate to the `build-dependencies`
section of you `Cargo.toml` file in order to make it available for the `build.rs` file that you will create in the next step:
+
[source,toml]
----
[build-dependencies]
pdk = { version = "1.1.0", registry = "anypoint" }
protobuf-codegen = "3.5.0"
----

* Create a `build.rs` file in the root of your project, to be run automatically by `cargo` when building your project to generate
the Protocol Buffers support code:
+
[source,rust]
----
fn main() {
    protobuf_codegen::Codegen::new()
        .pure() // Use the pure Rust parser for Protocol Buffers.
        .includes(["proto"]) // Include the `proto` directory in the scan.
        .input("proto/hello.proto") // Compile the `hello.proto` file.
        .cargo_out_dir("protos") // Put the generated code into the cargo output dir, inside a `protos` directory.
        .run_from_script(); // Generate all.
}
----
* Import the generated code as module in the `lib.rs` file.
+
[source,rust]
----
// Make the `hello` module available.
include!(concat!(env!("OUT_DIR"), "/protos/mod.rs"));
----

* Now you can write a `grpc::GrpcClient` wrapper for encapsulating calls to `HelloService`.
+
[source,rust]
----
pub struct HelloClient {
   client: grpc::GrpcClient,
   service: Service,
}

impl HelloClient {
   pub fn new(client: grpc::GrpcClient, service: Service) -> Self {
      Self {
        client,
        service,
      }
   }

   pub fn say_hello(&self, request: &hello::HelloRequest) -> Result<hello::HelloResponse, GrpcClientError> {
      let response = client
        .request(&self.service)
        .service("HelloService")
        .method("SayHello")
        .protobuf() // enable Protocol Buffers support.
        .send(request)
        .await?
        into_inner();

     Ok(response)
   }
----

* To use the wrapper, just create and call it from an `async` function, por example `configure()`:
+
[source,rust]
----
#[entrypoint]
async fn configure(
    launcher: Launcher,
    Configuration(bytes): Configuration,
    client: GrpcClient,
) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();

    let hello_client = HelloClient::new(client, config.service);

    let hello_result = hello_client.say_hello(hello::HelloRequest {
        greeting: "PDK".to_string()
    })
    .await;
}
----

== See Also

* `protobuf` crate https://crates.io/crates/protobuf[documentation].
* xref:policies-pdk-configure-features.adoc[]
