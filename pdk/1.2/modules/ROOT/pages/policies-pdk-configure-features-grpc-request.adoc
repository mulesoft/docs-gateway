= Performing a Unary gRPC Call
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images

NOTE: To view an example policy project that makes gRPC calls, see https://github.com/mulesoft/pdk-custom-policy-examples/blob/main/simple-oauth-2-grpc-validation/README.md[Simple OAuth 2.0 gRPC Validation Policy Example^].

To interact with external services, a policy can use gRPC calls. You can only make gRPC calls from the request filter or the response filter.

Custom policies only support unary gRPC calls. Policies do not support gRPC streaming.

Depending on where you inject the `GrpcClient`, you can make calls from the request, response, or both filters.

* To enable calls in the request and response filters, inject the client parameter into the `#[entrypoint]` function:
+
[source,Rust]
----
#[entrypoint]
async fn configure(
    launcher: Launcher,
    Configuration(bytes): Configuration,
    client: grpc::GrpcClient,
) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();

    // Both request and the response handlers will use the client   
    let filter = on_request(|request_state| request_filter(request_state, &config, &client))
        .on_response(|response_state, request_data| {
            response_filter(response_state, request_data, &config, &client)
        });

    launcher.launch(filter).await?;
    Ok(())
}
----

* To enable calls only in the request or the response, inject the client parameters either in the `on_request` or `on_response` wrapper functions:
+
[source,Rust]
----
// Handler with the logic for incoming requests
async fn request_filter(state: RequestState, conf: &Config, client: grpc::GrpcClient) {
 ...
}

#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).unwrap();

    // For incoming request events, using the on_request wrapper, inject the client and pass it to the request_filter handler
    launcher
        .launch(on_request(|request, client| {
            request_filter(request, &config, client)
        }))
        .await?;
    Ok(())
}
----

NOTE: The `pdk::hl::grpc` module contains the gRPC client functionality. If you import all PDK modules (`pdk::hl::*`), refer to the gRPC client as `grpc::GrpcClient`.

Define your gRPC service as a parameter in your schema definition to make gRPC requests. To learn more about defining parameters, see xref:policies-pdk-create-schema-definition.adoc[]

The following code snippet provides an example schema definition for an external service:

[source,yaml]
----
properties:
      externalService:
          type: string
          format: service
----

In the policy's Rust source code, you can access the defined external service in the `Config` struct. For example, the following code snippet invokes the `HelloService` gRPC service that has the `SayHello` method:

[source,rust]
----

async fn say_hello(config: &Config, grpc_client: &grpc::GrpcClient, message: &[u8]) -> Result<Vec<u8>, grpc::GrpcClientError> {
    let response = grpc_client
        .request(&config.external_service)
        .service("HelloService")
        .method("SayHello")
        .send(message_bytes)
        .await?
        .into_inner()

    Ok(response)
}
----

NOTE: The message is raw bytes. You must explicitly serialize the message in a serialization format such as JSON.

== Protocol Buffers Messages

The `grpc::GrpcClient` supports Protocol Buffers. To use Protocol Buffers, include the https://crates.io/crates/protobuf[protobuf crate] for encoding Protocol Buffers messages.


To configure Protocol Buffers:

. Add the `protobuf` crate as a dependency to your `Cargo.toml` file:
+
[source,toml]
----
[dependencies]
pdk = { version = "1.1.0", registry = "anypoint" }
protobuf = "3.5.0"
----

. Create a folder named `proto` to place the `.proto` definition files.

. Create a file named `hello.proto` inside the `proto` folder, for example:
+
----
└─ proto/  # Contains the Protocol Buffers definition files.
   └── hello.proto # Contains the Protocol Buffers definitions for the `hello` package.
----

. Open the `hello.proto` file and copy and paste the following definitions into it:
+
[source,proto]
----
syntax = "proto2";

package hello;

service HelloService {
  rpc SayHello(HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  required string greeting = 1;
}

message HelloResponse {
  required string reply = 1;
}
----

. Add the `profobuf-codegen` crate to the `build-dependencies` section of you `Cargo.toml` file to make it available for the `build.rs` file created in the next step:
+
[source,toml]
----
[build-dependencies]
pdk = { version = "1.1.0", registry = "anypoint" }
protobuf-codegen = "3.5.0"
----

. Create a file named `build.rs` file in the root folder of your project. `cargo` populates the following code automatically in the `build.rs` file when your project builds:
+
[source,rust]
----
fn main() {
    protobuf_codegen::Codegen::new()
        .pure() // Use the pure Rust parser for Protocol Buffers.
        .includes(["proto"]) // Include the `proto` directory in the scan.
        .input("proto/hello.proto") // Compile the `hello.proto` file.
        .cargo_out_dir("protos") // Put the generated code into the cargo output dir, inside a `protos` directory.
        .run_from_script(); // Generate all.
}
----

. Add the following line in the `lib.rs` file to import the generated code:
+
[source,rust]
----
// Make the `hello` module available.
include!(concat!(env!("OUT_DIR"), "/protos/mod.rs"));
----

. Use the following code as an example of how to write a `grpc::GrpcClient` wrapper for encapsulating calls to `HelloService`:
+
[source,rust]
----
pub struct HelloClient {
   grpc_client: grpc::GrpcClient,
   service: Service,
}

impl HelloClient {
   pub fn new(grpc_client: grpc::GrpcClient, service: Service) -> Self {
      Self {
        grpc_client,
        service,
      }
   }

   pub fn say_hello(&self, request: &hello::HelloRequest) -> Result<hello::HelloResponse, GrpcClientError> {
      let response = self
        .grpc_client
        .request(&self.service)
        .service("HelloService")
        .method("SayHello")
        .protobuf() // enable Protocol Buffers support.
        .send(request)
        .await?
        into_inner();

     Ok(response)
   }
----

. Use the wrappers by calling them from an `async` context:
+
[source,rust]
----

let hello_client = HelloClient::new(grpc_client, config.service);

let hello_response = hello_client.say_hello(&hello::HelloRequest {
    greeting: "PDK".to_string()
})
.await?;

----

== See Also

* `protobuf` crate https://crates.io/crates/protobuf[documentation].
* xref:policies-pdk-configure-features.adoc[]
