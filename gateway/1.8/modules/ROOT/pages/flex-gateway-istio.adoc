= Integrating Flex Gateway with Istio
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:imagesdir: ../assets/images


image:flex-istio-deployment.png["Flex Gateway deployed using Istio sidecars and a Istio Ingress gateway",width=65%,align="center']

== Before You Begin

Before you begin, install the following prerequisites:

* https://docs.docker.com/get-docker/[Docker^]

* https://k3d.io/v5.0.0/#installation[K3d] to create a kubernetes cluster inside of docker

* https://kubernetes.io/docs/tasks/tools/#kubectl[kubectl] to control the Kubernetes cluster

* https://helm.sh/docs/intro/install/[Helm] to install Flex Gateway and Istio

== Setup Environment

. Create the kubernetes cluster used for this demo or skip this step if you already have one:
+
[source,ssh]
----
k3d cluster create demo-istio --k3s-arg "--disable=traefik@server:0" --port '80:80@server:0' --port '443:443@server:0'
----

. Add Flex Gateway and Istio helm repo:
+
[source,ssh]
----
helm repo add istio https://istio-release.storage.googleapis.com/charts \
&& helm repo add flex-gateway https://flex-packages.anypoint.mulesoft.com/helm \
&& helm repo up
----

. Install Istio:
+
.. Install the Istio base chart which contains cluster-wide Custom Resource Definitions (CRDs) which must be installed prior to the deployment of the Istio control plane:
+
[source,ssh]
----
helm upgrade -i --wait --create-namespace -n istio-system istio-base istio/base --version 1.21.2 --set defaultRevision=default
----
+
.. Install the Istio discovery chart which deploys the istiod service
+
[source,ssh]
----
helm upgrade -i --wait --create-namespace -n istio-system istiod istio/istiod --version 1.21.2
----
+
.. Install an ingress gateway:
+
[source,ssh]
----
helm upgrade -i --wait --create-namespace -n istio-system istio-ingress istio/gateway --version 1.21.2
----

. Install Flex Gateway:

.. Create the namespace and setup de label to enable the sidecar inject:
+
[source,ssh]
----
kubectl create ns flex && kubectl label ns flex istio-injection=enabled --overwrite
----
+
.. Install Flex Gateway:
+
[source,ssh]
----
helm upgrade -i --wait -n flex --version 1.7.0 flex flex-gateway/flex-gateway \
--set gateway.scope=Namespace \
--set gateway.mode=connected \
--set service.type=ClusterIP \
--set service.http.port=8081 \
--set service.https.enabled=false \
--set-file registration.content=registration.yaml
----
+
.. List all Services and ApiInstances created:
+
[source,ssh]
----
kubectl -n flex get svc
----

. Install Bookinfo application:
+
.. Enable Istio injection label in the default namespace and install bookinfo application on it:
+
[source,ssh]
----
kubectl create ns bookinfo \
&& kubectl label ns bookinfo istio-injection=enabled --overwrite \
&& kubectl -n bookinfo apply -l version!=v2,version!=v3 -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/bookinfo/platform/kube/bookinfo.yaml
----
+
.. Check the status of the pods:
+
[source,ssh]
----
kubectl -n bookinfo get pods 
----

. Install `sleep` application:
+
.. Install `sleep` application used to test traffic:
+
[source,ssh]
----
kubectl create ns test \
&& kubectl label ns test istio-injection=enabled --overwrite \
&& kubectl -n test apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/sleep/sleep.yaml
----
+
.. Check the status of the pods:
+
[source,ssh]
----
kubectl -n test get pods
----

== Forward Ingress Traffic

.  Create the ingress ApiInstance and forward all incoming traffic to the `productpage` service in the `bookinfo` namespace:
+
** Local Mode:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: ApiInstance
metadata:
  name: ingress
  namespace: flex
spec:
  address: http://0.0.0.0:8081/ingress/
  services:
    productpage:
      address: http://productpage.bookinfo.svc:9080
EOF
----
+
** Connected Mode:
+
...

. Create the `flex` Istio Gateway and forward the ingress traffic to Flex using a VirtualService:
+
.. Create the gateway:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: flex
  namespace: flex
spec:
  selector:
    app: istio-ingress
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "*"
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: flex
  namespace: flex
spec:
  hosts:
  - "*"
  gateways:
  - flex
  http:
  - route:
    - destination:
        host: flex
        port:
          number: 8081
    rewrite:
      uri: /ingress/
EOF
----
+
.. Wait a few seconds (around 10s) and try hit the /api/v1/products/1 page:
+
[source,ssh]
----
curl -v http://localhost/api/v1/products/1
----
+
.. Ensure your receive the following output:
+
[source,ssh]
----
< HTTP/1.1 200 OK
< server: istio-envoy
< date: Tue, 27 Feb 2024 22:06:33 GMT
< content-type: application/json
< content-length: 195
< x-envoy-upstream-service-time: 8
<
* Connection #0 to host localhost left intact
{"id": 2, "author": "William Shakespeare", "year": 1595, "type": "paperback", "pages": 200, "publisher": "PublisherA", "language": "English", "ISBN-10": "1234567890", "ISBN-13": "123-1234567890"}
----

. Add basic-auth policy to ingress ApiInstance to protect it:
+
.. Add the policy:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: ApiInstance
metadata:
  name: ingress
  namespace: flex
spec:
  address: http://0.0.0.0:8081/ingress/
  services:
    productpage:
      address: http://productpage.bookinfo.svc:9080
  policies:
  - policyRef:
      name: http-basic-authentication-flex
    config:
      username: foo
      password: bar
EOF
----
+
.. Wait a few seconds (around 10s) and try hit again:
+
[source,ssh]
----
curl -v http://localhost/
----
+
.. Ensure you receive a 401 response.

. Add the message logging policy to log the traffic:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: ApiInstance
metadata:
  name: ingress
  namespace: flex
spec:
  address: http://0.0.0.0:8081/ingress/
  services:
    productpage:
      address: http://productpage.bookinfo.svc:9080
  policies:
  - policyRef:
      name: http-basic-authentication-flex
    config:
      username: foo
      password: bar
  - policyRef:
      name: message-logging-flex
    config:
      loggingConfiguration:
      - itemName: "Request"
        itemData:
          message: "#['> ' ++ attributes.version ++ ' ' ++  attributes.method ++ ' ' ++ attributes.headers.host ++ attributes.requestUri]"
          level: "INFO"
          firstSection: true
      - itemName: "Response"
        itemData:
          message: "#['< Status=' ++ attributes.statusCode ++ ' Length=' ++ (attributes.headers['content-length'] default 'none') ++ ' Time=' ++ (attributes.headers['x-envoy-upstream-service-time'] default 'none')]"
          level: "INFO"
          secondSection: true
    order: 0 
EOF
----

== Create a Service to Serve Traffic

. First we need to create the `bookinfo-reviews` ApiInstance to forward the incoming traffic to the `reviews` Service in the `bookinfo` namespace:

** Local Mode:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: ApiInstance
metadata:
  name: bookinfo-reviews
  namespace: flex
spec:
  address: http://0.0.0.0:8081/bookinfo/reviews/
  services:
    upstream:
      address: http://reviews.bookinfo.svc:9080
  policies:
  - policyRef:
      name: message-logging-flex
    config:
      loggingConfiguration:
      - itemName: "Request"
        itemData:
          message: "#['> ' ++ attributes.version ++ ' ' ++  attributes.method ++ ' ' ++ attributes.headers.host ++ attributes.requestUri]"
          level: "INFO"
          firstSection: true
      - itemName: "Response"
        itemData:
          message: "#['< Status=' ++ attributes.statusCode ++ ' Length=' ++ (attributes.headers['content-length'] default 'none') ++ ' Time=' ++ (attributes.headers['x-envoy-upstream-service-time'] default 'none')]"
          level: "INFO"
          secondSection: true
EOF
----

** Connected Mode:

. Intercept the traffic from `productpage` service to `reviews` service and forward it to `flex` service:
+
.. Create the API instance:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: bookinfo-reviews
  namespace: istio-system
spec:
  hosts:
  - reviews.bookinfo.svc.cluster.local
  http:
  - match:
    - sourceLabels:
        app: flex
    route:
    - destination:
        host: reviews.bookinfo.svc.cluster.local
        port:
          number: 9080
  - route:
    - destination:
        host: flex.flex.svc.cluster.local
        port:
          number: 8081
    rewrite:
      uri: /bookinfo/reviews/
EOF
----
+
.. Now when we hit the `/productpage` page, using user `foo` and pass `bar`:
+
[source,ssh]
----
curl -v -u foo:bar http://localhost/productpage
----
+
.. Check the logs to ensure the request sent from the productpage service to the reviews service is handled by Flex. The logs should appear as follows:
+
[source,ssh]
----
[flex-gateway-envoy][info] wasm log productpage-message-logging-flex-2.flex.productpage.flex.svc main: [policy: productpage-message-logging-flex-2.flex][api: productpage.flex.svc][req: 6e1f7c32-918d-4b6a-af3f-36a4430f80ae] [accessLog] > HTTP/1.1 GET localhost/ingress/productpage
[flex-gateway-envoy][info] wasm log bookinfo-reviews-message-logging-flex-1.flex.bookinfo-reviews.flex.svc main: [policy: bookinfo-reviews-message-logging-flex-1.flex][api: bookinfo-reviews.flex.svc][req: b23e9c64-a2aa-4464-8984-d1dd6c18f7ea] [accessLog] > HTTP/1.1 GET reviews:9080/bookinfo/reviews/reviews/0
----

.. Apply the rate-limit policy to all request sent to reviews service to protect it:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: gateway.mulesoft.com/v1alpha1
kind: ApiInstance
metadata:
  name: bookinfo-reviews
  namespace: flex
spec:
  address: http://0.0.0.0:8081/bookinfo/reviews/
  services:
    upstream:
      address: http://reviews.bookinfo.svc:9080
  policies:
  - policyRef:
      name: message-logging-flex
    config:
      loggingConfiguration:
      - itemName: "Request"
        itemData:
          message: "#['> ' ++ attributes.version ++ ' ' ++  attributes.method ++ ' ' ++ attributes.headers.host ++ attributes.requestUri]"
          level: "INFO"
          firstSection: true
      - itemName: "Response"
        itemData:
          message: "#['< Status=' ++ attributes.statusCode ++ ' Length=' ++ (attributes.headers['content-length'] default 'none') ++ ' Time=' ++ (attributes.headers['x-envoy-upstream-service-time'] default 'none')]"
          level: "INFO"
          secondSection: true
    order: 0
  - policyRef:
      name: rate-limiting-flex
    config:
      rateLimits:
      - timePeriodInMilliseconds: 60000
        maximumRequests: 2
      exposeHeaders: true
EOF
----

. Restrict direct access to `bookinfo` services:
+
.. Restrict access:
+
[source,ssh]
----
cat <<EOF | kubectl apply -f -
---
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: flex-allow
  namespace: bookinfo
spec:
  action: ALLOW
  rules:
  - from:
    - source:
        namespaces:
        - flex
        - bookinfo
EOF
----
+
.. Try to hit the details service, from the test namespace:
+
[source,ssh]
----
kubectl -n test exec -ti -c sleep $(kubectl -n test get pod --no-headers -o=name) -- curl -v details.bookinfo:9080/details/0
----
+
The following forbidden response returns:
+
[source,ssh]
----
< HTTP/1.1 403 Forbidden
< content-length: 19
< content-type: text/plain
< date: Thu, 09 May 2024 15:51:11 GMT
< server: envoy
< x-envoy-upstream-service-time: 0
<
* Connection #0 to host details.bookinfo left intact
RBAC: access denied
----
+
.. Check how we can access it from the flex namespace:
+
[source,ssh]
----
kubectl -n flex exec -ti -c app  $(kubectl -n flex get pod --no-headers -o=name) -- flexctl check http http://details.bookinfo:9080/details/0
----
+
See the following response:
+
[source,ssh]
----
[flexctl][info] Access to http address 'http://details.bookinfo:9080/details/0': ok
----

== See Also